{
  "version": 3,
  "sources": ["../src/util.js", "../src/constants.js", "../src/events.js", "../src/item.js", "../src/wheel.js"],
  "sourcesContent": ["/**\n * Get a random integer between `min` (inclusive) and `max` (exclusive).\n */\nexport function getRandomInt(min = 0, max = 0) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/**\n * Get a random number between `min` (inclusive) and `max` (inclusive).\n * Control the number of decimal places with `round`.\n */\nexport function getRandomFloat(min = 0, max = 0, round = 14) {\n  return parseFloat((Math.random() * (max - min) + min).toFixed(round));\n}\n\n/**\n * Convert degrees to radians.\n */\nexport function degRad(degrees = 0) {\n  return degrees * Math.PI / 180;\n}\n\n/**\n * Return true if `angle` is between `arcStart` (inclusive) and `arcEnd` (exclusive).\n * Example: `(0, 359, 1) == true`\n * Example: `(0, 1, 2) == false`\n */\nexport function isAngleBetween(angle, arcStart, arcEnd) {\n  if (arcStart < arcEnd) return arcStart <= angle && angle < arcEnd;\n  return arcStart <= angle || angle < arcEnd;\n}\n\n/**\n * Average the values in `array`.\n * Only operate on truthy values.\n * Truthy values that are not Numbers count as 1.\n * Return 0 if the array is empty.\n */\nexport function aveArray(array = []) {\n  let sum = 0;\n  for (const val of array) {\n    if (val) sum += ((typeof val === 'number') ? val : 1);\n  }\n  return sum / array.length || 0;\n}\n\n/**\n * Calculate the largest font size that `text` can have without exceeding `maxWidth`.\n * Won't work unless `fontFamily` has been loaded.\n */\nexport function getFontSizeToFit(text, fontFamily, maxWidth, canvasContext) {\n  canvasContext.save();\n  canvasContext.font = `1px ${fontFamily}`;\n  const w = canvasContext.measureText(text).width;\n  canvasContext.restore();\n  return maxWidth / w;\n}\n\n/**\n * Return true if the given point is inside a circle.\n * cx, cy is circle center.\n * radius is circle radius.\n */\nexport function isPointInCircle(point = {x: 0, y: 0}, cx, cy, radius) {\n  const distanceSquared = ((point.x - cx) ** 2) + ((point.y - cy) ** 2);\n  return distanceSquared <= (radius ** 2);\n}\n\n/**\n * Translate the given point from the viewport's coordinate space to the element's coordinate space.\n */\nexport function translateXYToElement(point = {x: 0, y: 0}, element = {}, devicePixelRatio = 1) {\n  const rect = element.getBoundingClientRect();\n  return {\n    x: (point.x - rect.left) * devicePixelRatio,\n    y: (point.y - rect.top) * devicePixelRatio,\n  };\n}\n\nexport function getMouseButtonsPressed(event = {}) {\n  return [1, 2, 4, 8, 16].filter(i => event.buttons & i);\n}\n\n/**\n * Source: https://stackoverflow.com/a/47653643/737393\n */\nexport function getAngle(originX, originY, targetX, targetY) {\n    const dx = originX - targetX;\n    const dy = originY - targetY;\n\n    let theta = Math.atan2(-dy, -dx);\n    theta *= 180 / Math.PI;\n    if (theta < 0) theta += 360;\n\n    return theta;\n}\n\n/**\n * Return the distance between two points.\n */\nexport function getDistanceBetweenPoints(point1 = {x: 0, y: 0}, point2 = {x: 0, y: 0}) {\n  return Math.hypot(point2.x - point1.x, point2.y - point1.y);\n}\n\n/**\n * Add two angles together.\n * Return a positive number between 0 and 359.9999.\n */\nexport function addAngle(a = 0, b = 0) {\n  const sum = a + b;\n  let result;\n\n  if (sum > 0) {\n    result = sum % 360;\n  } else {\n    result = 360 + (sum % 360);\n  }\n  if (result === 360) result = 0;\n\n  return result;\n}\n\n/**\n * Return the shortest difference (in degrees) between two angles.\n * Only accept angles between 0 and 360.\n */\nexport function diffAngle(a = 0, b = 0) {\n  const offsetFrom180 = 180 - b;\n  const aWithOffset = addAngle(a, offsetFrom180);\n  return 180 - aWithOffset;\n}\n\n/**\n * Calculate what the new rotation of a wheel should be, so that the relative angle `targetAngle` will be at 0 degrees (north).\n * targetAngle = a value between 0 and 360.\n * direction = the direction the wheel can spin. 1 for clockwise, -1 for antiClockwise.\n */\nexport function calcWheelRotationForTargetAngle(currentRotation = 0, targetAngle = 0, direction = 1) {\n\n  let angle = ((currentRotation % 360) + targetAngle) % 360;\n\n  // Ignore tiny values.\n  // Due to floating point arithmetic, ocassionally the input angles won't add up exactly\n  // and this can push the angle slightly above 360.\n  angle = fixFloat(angle);\n\n  // Apply direction:\n  angle = ((direction === 1) ? (360 - angle) : 360 + angle) % 360;\n  angle *= direction;\n\n  return currentRotation + angle;\n}\n\nexport function isObject(v) {\n  return typeof v === 'object' && !Array.isArray(v) && v !== null;\n}\n\nexport function isNumber(n) {\n  return typeof n === 'number' && !Number.isNaN(n);\n}\n\nexport function setProp({val, isValid, errorMessage, defaultValue, action = null}) {\n  if (isValid) {\n    return (action) ? action() : val;\n  } else if (val === undefined) {\n    return defaultValue;\n  }\n  throw new Error(errorMessage);\n}\n\n/**\n * Return true if image has loaded.\n */\nexport function isImageLoaded(image) {\n  // We can detect a broken image (didn't load) by checking the natural width/height.\n  return image && image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;\n}\n\nexport function fixFloat(f = 0) {\n  return Number(f.toFixed(9));\n}\n\n/**\n * Easing function.\n */\nexport function easeSinOut(n) {\n  return Math.sin((n * Math.PI) / 2);\n}\n\nexport function dispatchEvent(el, eventName, detail = {}) {\n  const event = new CustomEvent(eventName, {\n    bubbles: true,\n    cancelable: true,\n    detail,\n  });\n  return el.dispatchEvent(event);\n}", "/**\n * Adjustment when drawing arcs to ensure 0\u00B0 is north (due to canvas drawing arcs from 90\u00B0).\n */\nexport const arcAdjust = -90;\n\nexport const baseCanvasSize = 500; // 500 seemed to be a good value for this.\n\n/**\n * The period in milliseconds that we record drag events.\n * Used to calculate how fast the wheel should spin after the drag ends.\n * For example, if the wheel was dragged 20 degrees over the last 250ms,\n * then it should continue rotating at a speed of 20 degrees every 250ms after the drag ends.\n */\nexport const dragCapturePeriod = 250;\n\n/**\n * Text alignment enum.\n */\nexport const AlignText = Object.freeze({\n  left: 'left',\n  right: 'right',\n  center: 'center',\n});\n\n/**\n * Wheel property defaults.\n */\nexport const Defaults = Object.freeze({\n  wheel: {\n    borderColor: '#000',\n    borderWidth: 1,\n    debug: false,\n    image: null,\n    isInteractive: true,\n    itemBackgroundColors: ['#fff'],\n    itemLabelAlign: AlignText.right,\n    itemLabelBaselineOffset: 0,\n    itemLabelColors: ['#000'],\n    itemLabelFont: 'sans-serif',\n    itemLabelFontSizeMax: baseCanvasSize,\n    itemLabelRadius: 0.85,\n    itemLabelRadiusMax: 0.2,\n    itemLabelRotation: 0,\n    items: [],\n    lineColor: '#000',\n    lineWidth: 1,\n    pixelRatio: 0,\n    radius: 0.95,\n    rotation: 0,\n    rotationResistance: -35,\n    rotationSpeedMax: 300,\n    offset: {w: 0, h: 0},\n    onCurrentIndexChange: null,\n    onRest: null,\n    onSpin: null,\n    overlayImage: null,\n    pointerAngle: 0,\n  },\n  item: {\n    backgroundColor: null,\n    image: null,\n    imageRadius: 0.5,\n    imageRotation: 0,\n    imageScale: 1,\n    label: '',\n    labelColor: null,\n    value: null,\n    weight: 1,\n  },\n});\n\nexport const Debugging = Object.freeze({\n  pointerLineColor: '#ff00ff',\n  labelOutlineColor: '#ff00ff',\n  labelRadiusColor: '#00ff00',\n  dragEventHue: 200,\n});\n\nexport const EventName = Object.freeze({\n  currentIndexChange: 'spin-wheel:current-index-change',\n  rest: 'spin-wheel:rest',\n  spin: 'spin-wheel:spin',\n});", "export function register(wheel = {}) {\n\n  registerPointerEvents(wheel);\n\n  // Register window resize event:\n  wheel._handler_onResize = e => wheel.resize(e);\n  window.addEventListener('resize', wheel._handler_onResize);\n\n  // Monitor when the device resolution (devicePixelRatio) changes:\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\n  const updatePixelRatio = () => {\n    wheel.resize();\n    matchMedia(`(resolution: ${pr}dppx)`)\n      .addEventListener('change', updatePixelRatio, { once: true });\n  };\n\n}\n\nexport function unregister(wheel = {}) {\n\n  const canvas = wheel.canvas;\n\n  if ('PointerEvent' in window) {\n    canvas.removeEventListener('pointerdown', wheel._handler_onPointerDown);\n    canvas.removeEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n  } else {\n    canvas.removeEventListener('touchstart', wheel._handler_onTouchStart);\n    canvas.removeEventListener('mousedown', wheel._handler_onMouseDown);\n    canvas.removeEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n  }\n\n  window.removeEventListener('resize', wheel._handler_onResize);\n\n}\n\nfunction registerPointerEvents(wheel = {}) {\n  // Adapted from https://glitch.com/~jake-in-the-box\n\n  const canvas = wheel.canvas;\n\n  wheel._handler_onPointerMoveRefreshCursor = (e = {}) => {\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n    wheel.isCursorOverWheel = wheel.wheelHitTest(point);\n    wheel.refreshCursor();\n  };\n\n  wheel._handler_onMouseMoveRefreshCursor = (e = {}) => {\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n    wheel.isCursorOverWheel = wheel.wheelHitTest(point);\n    wheel.refreshCursor();\n  };\n\n  wheel._handler_onPointerDown = (e = {}) => {\n\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    e.preventDefault();\n    wheel.dragStart(point);\n    canvas.setPointerCapture(e.pointerId);\n    canvas.addEventListener('pointermove', onPointerMove);\n    canvas.addEventListener('pointerup', onPointerUp);\n    canvas.addEventListener('pointercancel', onPointerUp);\n    canvas.addEventListener('pointerout', onPointerUp);\n\n    function onPointerMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.clientX,\n        y: e.clientY,\n      });\n    }\n\n    function onPointerUp(e = {}) {\n      e.preventDefault();\n      canvas.releasePointerCapture(e.pointerId);\n      canvas.removeEventListener('pointermove', onPointerMove);\n      canvas.removeEventListener('pointerup', onPointerUp);\n      canvas.removeEventListener('pointercancel', onPointerUp);\n      canvas.removeEventListener('pointerout', onPointerUp);\n      wheel.dragEnd();\n    }\n\n  };\n\n  wheel._handler_onMouseDown = (e = {}) => {\n\n    const point = {\n      x: e.clientX,\n      y: e.clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    wheel.dragStart(point);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n\n    function onMouseMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.clientX,\n        y: e.clientY,\n      });\n    }\n\n    function onMouseUp(e = {}) {\n      e.preventDefault();\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      wheel.dragEnd();\n    }\n\n  };\n\n  wheel._handler_onTouchStart = (e = {}) => {\n\n    const point = {\n      x: e.targetTouches[0].clientX,\n      y: e.targetTouches[0].clientY,\n    };\n\n    if (!wheel.isInteractive) return;\n    if (!wheel.wheelHitTest(point)) return;\n\n    e.preventDefault();\n    wheel.dragStart(point);\n    canvas.addEventListener('touchmove', onTouchMove);\n    canvas.addEventListener('touchend', onTouchEnd);\n    canvas.addEventListener('touchcancel', onTouchEnd);\n\n    function onTouchMove(e = {}) {\n      e.preventDefault();\n      wheel.dragMove({\n        x: e.targetTouches[0].clientX,\n        y: e.targetTouches[0].clientY,\n      });\n    }\n\n    function onTouchEnd(e = {}) {\n      e.preventDefault();\n      canvas.removeEventListener('touchmove', onTouchMove);\n      canvas.removeEventListener('touchend', onTouchEnd);\n      canvas.removeEventListener('touchcancel', onTouchEnd);\n      wheel.dragEnd();\n    }\n\n  };\n\n  if ('PointerEvent' in window) {\n    canvas.addEventListener('pointerdown', wheel._handler_onPointerDown);\n    canvas.addEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n  } else {\n    canvas.addEventListener('touchstart', wheel._handler_onTouchStart);\n    canvas.addEventListener('mousedown', wheel._handler_onMouseDown);\n    canvas.addEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n  }\n\n}\n", "import * as util from './util.js';\nimport {Defaults} from './constants.js';\n\nexport class Item {\n\n  constructor(wheel, props = {}) {\n\n    // Validate params.\n    if (!util.isObject(wheel)) throw new Error('wheel must be an instance of Wheel'); // Ideally we would use instanceof, however importing the Wheel class would create a circular ref.\n    if (!util.isObject(props) && props !== null) throw new Error('props must be an Object or null');\n\n    this._wheel = wheel;\n\n    // Assign default values.\n    // This avoids null exceptions when we initalise each property one-by-one in `init()`.\n    for (const i of Object.keys(Defaults.item)) {\n      this['_' + i] = Defaults.item[i];\n    }\n\n    if (props) {\n      this.init(props);\n    } else {\n      this.init(Defaults.item);\n    }\n\n  }\n\n  /**\n   * Initialise all properties.\n   */\n  init(props = {}) {\n    this.backgroundColor = props.backgroundColor;\n    this.image = props.image;\n    this.imageRadius = props.imageRadius;\n    this.imageRotation = props.imageRotation;\n    this.imageScale = props.imageScale;\n    this.label = props.label;\n    this.labelColor = props.labelColor;\n    this.value = props.value;\n    this.weight = props.weight;\n  }\n\n  /**\n   * The background color of the item.\n   * Falls back to `Wheel.itemBackgroundColors` when `null`.\n   * Example: `'#fff'`.\n   */\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  set backgroundColor(val) {\n    if (typeof val === 'string') {\n      this._backgroundColor = val;\n    } else {\n      this._backgroundColor = Defaults.item.backgroundColor;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The url of an image that will be drawn on the item.\n   * Any part of the image that extends outside the item will be clipped.\n   */\n  get image() {\n    return this._image?.src ?? null;\n  }\n  set image(val) {\n    let img;\n    if (typeof val === 'string') {\n      img = new Image();\n      img.src = val;\n      img.onload = e => this._wheel.refresh();\n    } else {\n      img = Defaults.item.image;\n    }\n    this._image = img;\n    this._wheel.refresh();\n  }\n\n  get imageObj() {\n    return this._image;\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel) to draw the center of `Item.image`.\n   */\n  get imageRadius() {\n    return this._imageRadius;\n  }\n  set imageRadius(val) {\n    if (typeof val === 'number') {\n      this._imageRadius = val;\n    } else {\n      this._imageRadius = Defaults.item.imageRadius;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The rotation (angle in degrees) of `Item.image`.\n   */\n  get imageRotation() {\n    return this._imageRotation;\n  }\n  set imageRotation(val) {\n    if (typeof val === 'number') {\n      this._imageRotation = val;\n    } else {\n      this._imageRotation = Defaults.item.imageRotation;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The scale (as a percent) to resize `Item.image`.\n   */\n  get imageScale() {\n    return this._imageScale;\n  }\n  set imageScale(val) {\n    if (typeof val === 'number') {\n      this._imageScale = val;\n    } else {\n      this._imageScale = Defaults.item.imageScale;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The text that will be drawn on the item.\n   */\n  get label() {\n    return this._label;\n  }\n  set label(val) {\n    if (typeof val === 'string') {\n      this._label = val;\n    } else {\n      this._label = Defaults.item.label;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * The color of the label.\n   * Falls back to `Wheel.itemLabelColors` when `null`.\n   * Example: `'#000'`.\n   */\n  get labelColor() {\n    return this._labelColor;\n  }\n  set labelColor(val) {\n    if (typeof val === 'string') {\n      this._labelColor = val;\n    } else {\n      this._labelColor = Defaults.item.labelColor;\n    }\n    this._wheel.refresh();\n  }\n\n  /**\n   * Some value that has meaning to your application.\n   * For example, a reference to the object representing the item on the wheel, or a database id.\n   */\n  get value() {\n    return this._value;\n  }\n  set value(val) {\n    if (val !== undefined) {\n      this._value = val;\n    } else {\n      this._value = Defaults.item.value;\n    }\n  }\n\n  /**\n   * The proportional size of the item relative to other items on the wheel.\n   * For example, if you have 2 items where `item[0]` has a weight of `1` and `item[1]` has a weight of `2`,\n   * then `item[0]` will take up 1/3 of the space on the wheel.\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(val) {\n    if (typeof val === 'number') {\n      this._weight = val;\n    } else {\n      this._weight = Defaults.item.weight;\n    }\n  }\n\n  /**\n   * Get the 0-based index of this item.\n   */\n  getIndex() {\n    const index = this._wheel.items.findIndex(i => i === this);\n    if (index === -1) throw new Error('Item not found in parent Wheel');\n    return index;\n  }\n\n  /**\n   * Get the angle (in degrees) that this item ends at (exclusive), ignoring the current `rotation` of the wheel.\n   */\n  getCenterAngle() {\n    const angle = this._wheel.getItemAngles()[ this.getIndex() ];\n    return angle.start + ((angle.end - angle.start) / 2);\n  }\n\n  /**\n   * Get the angle (in degrees) that this item starts at (inclusive), ignoring the current `rotation` of the wheel.\n   */\n  getStartAngle() {\n    return this._wheel.getItemAngles()[ this.getIndex() ].start;\n  }\n\n  /**\n   * Get the angle (in degrees) that this item ends at (inclusive), ignoring the current `rotation` of the wheel.\n   */\n  getEndAngle() {\n    return this._wheel.getItemAngles()[ this.getIndex() ].end;\n  }\n\n  /**\n   * Return a random angle (in degrees) between this item's start angle (inclusive) and end angle (inclusive).\n   */\n  getRandomAngle() {\n    return util.getRandomFloat(this.getStartAngle(), this.getEndAngle());\n  }\n\n}\n", "import * as util from './util.js';\nimport * as Constants from './constants.js';\nimport {Defaults} from './constants.js';\nimport * as events from './events.js';\nimport {Item} from './item.js';\n\nwindow.customElements.define('spin-wheel', class Wheel extends HTMLElement {\n\n  constructor() {\n\n    super();\n\n    const shadow = this.attachShadow({mode: 'open'});\n    shadow.innerHTML = `\n      <style>\n        :host {\n          display: block;\n        }\n      </style>`;\n\n    this.canvas = document.createElement('canvas');\n    shadow.appendChild(this.canvas);\n\n    // Init some things:\n    this._context = this.canvas.getContext('2d');\n    this._frameRequestId = null;\n    this._rotationSpeed = 0;\n    this._rotationDirection = 1;\n    this._lastSpinFrameTime = undefined;\n\n    // Assign default values.\n    // This avoids null exceptions when we initalise each property one-by-one in `init()`.\n    for (const i of Object.keys(Defaults.wheel)) {\n      this['_' + i] = Defaults.wheel[i];\n    }\n\n    this.init(Defaults.wheel);\n\n  }\n\n  connectedCallback() { // Element added to page. Also called after moving.\n    events.register(this);\n  }\n\n  disconnectedCallback() { // Removed from page. Also called before moving.\n    events.unregister(this);\n  }\n\n  adoptedCallback() { // Moved to a new page.\n  }\n\n  /**\n   * Initialise all properties.\n   */\n  init(props = {}) {\n\n    if (!util.isObject(props) && props !== null) throw new Error('props must be an Object or null');\n\n    this._isInitialising = true;\n\n    this.borderColor = props.borderColor;\n    this.borderWidth = props.borderWidth;\n    this.debug = props.debug;\n    this.image = props.image;\n    this.isInteractive = props.isInteractive;\n    this.itemBackgroundColors = props.itemBackgroundColors;\n    this.itemLabelAlign = props.itemLabelAlign;\n    this.itemLabelBaselineOffset = props.itemLabelBaselineOffset;\n    this.itemLabelColors = props.itemLabelColors;\n    this.itemLabelFont = props.itemLabelFont;\n    this.itemLabelFontSizeMax = props.itemLabelFontSizeMax;\n    this.itemLabelRadius = props.itemLabelRadius;\n    this.itemLabelRadiusMax = props.itemLabelRadiusMax;\n    this.itemLabelRotation = props.itemLabelRotation;\n    this.items = props.items;\n    this.lineColor = props.lineColor;\n    this.lineWidth = props.lineWidth;\n    this.pixelRatio = props.pixelRatio;\n    this.rotationSpeedMax = props.rotationSpeedMax;\n    this.radius = props.radius;\n    this.rotation = props.rotation;\n    this.rotationResistance = props.rotationResistance;\n    this.offset = props.offset;\n    this.overlayImage = props.overlayImage;\n    this.pointerAngle = props.pointerAngle;\n  }\n\n  /**\n   * Resize the wheel to fit inside it's container.\n   * Call this after changing any property of the wheel that relates to it's size or position.\n   */\n  resize() {\n\n    // Get the smallest dimension of `canvasContainer`:\n    const w = this.clientWidth * this.getActualPixelRatio();\n    const h = this.clientHeight * this.getActualPixelRatio();\n\n    // Calc the size that the wheel needs to be to fit in it's container:\n    const minSize = Math.min(w, h);\n    const wheelSize = {\n      w: minSize - (minSize * this.offset.w),\n      h: minSize - (minSize * this.offset.h),\n    };\n    const scale = Math.min(w / wheelSize.w, h / wheelSize.h);\n    this._size = Math.max(wheelSize.w * scale, wheelSize.h * scale);\n\n    // Resize canvas element:\n    this.canvas.style.width = this.clientWidth + 'px';\n    this.canvas.style.height = this.clientHeight + 'px';\n    this.canvas.width = w;\n    this.canvas.height = h;\n\n    // Re-calculate the center of the wheel:\n    this._center = {\n      x: w / 2 + (w * this.offset.w),\n      y: h / 2 + (h * this.offset.h),\n    };\n\n    // Recalculate the wheel radius:\n    this._actualRadius = (this._size / 2) * this.radius;\n\n    // Adjust the font size of labels so they all fit inside `wheelRadius`:\n    this.itemLabelFontSize = this.itemLabelFontSizeMax * (this._size / Constants.baseCanvasSize);\n    this.labelMaxWidth = this._actualRadius * (this.itemLabelRadius - this.itemLabelRadiusMax);\n    for (const item of this._items) {\n      this.itemLabelFontSize = Math.min(this.itemLabelFontSize, util.getFontSizeToFit(item.label, this.itemLabelFont, this.labelMaxWidth, this._context));\n    }\n\n    this.refresh();\n\n  }\n\n  /**\n   * Main animation loop.\n   */\n  draw(now = 0) {\n\n    this._frameRequestId = null;\n\n    const ctx = this._context;\n\n    // Clear canvas.\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.animateRotation(now);\n\n    const angles = this.getItemAngles(this._rotation);\n\n    const actualBorderWidth = this.getActualBorderWidth();\n\n    // Set font:\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = this.itemLabelAlign;\n    ctx.font = this.itemLabelFontSize + 'px ' + this.itemLabelFont;\n\n    ctx.save();\n\n    // Build paths:\n    for (const [i, a] of angles.entries()) {\n\n      const path = new Path2D();\n      path.moveTo(this._center.x, this._center.y);\n      path.arc(\n        this._center.x,\n        this._center.y,\n        this._actualRadius - (actualBorderWidth / 2),\n        util.degRad(a.start + Constants.arcAdjust),\n        util.degRad(a.end + Constants.arcAdjust)\n      );\n\n      this._items[i].path = path;\n\n    }\n\n    this.drawItemBackgrounds(ctx, angles);\n    this.drawItemImages(ctx, angles);\n    this.drawItemLines(ctx, angles);\n    this.drawItemLabels(ctx, angles);\n    this.drawBorder(ctx);\n    this.drawImage(ctx, this._image, false);\n    this.drawImage(ctx, this._overlayImage, true);\n    this.drawPointerLine(ctx);\n    this.drawDragEvents(ctx);\n\n    this._isInitialising = false;\n\n  }\n\n  drawItemBackgrounds(ctx, angles = []) {\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      ctx.fillStyle = item.backgroundColor ?? (\n        // Fall back to a value from the repeating set:\n        this._itemBackgroundColors[i % this._itemBackgroundColors.length]\n      );\n\n      ctx.fill(item.path);\n\n    }\n\n  }\n\n  drawItemImages(ctx, angles = []) {\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      if (!util.isImageLoaded(item.imageObj)) continue;\n\n      ctx.save();\n\n      ctx.clip(item.path);\n\n      const angle = a.start + ((a.end - a.start) / 2);\n\n      ctx.translate(\n        this._center.x + Math.cos(util.degRad(angle + Constants.arcAdjust)) * (this._actualRadius * item.imageRadius),\n        this._center.y + Math.sin(util.degRad(angle + Constants.arcAdjust)) * (this._actualRadius * item.imageRadius)\n      );\n\n      ctx.rotate(util.degRad(angle + item.imageRotation));\n\n      const width = (this._size / 500) * item.imageObj.width * item.imageScale;\n      const height = (this._size / 500) * item.imageObj.height * item.imageScale;\n      const widthHalf = -width / 2;\n      const heightHalf = -height / 2;\n\n      ctx.drawImage(\n        item.imageObj,\n        widthHalf,\n        heightHalf,\n        width,\n        height\n      );\n\n      ctx.restore();\n\n    }\n\n  }\n\n  drawImage(ctx, image, isOverlay = false) {\n\n    if (!util.isImageLoaded(image)) return;\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    if (!isOverlay) ctx.rotate(util.degRad(this._rotation));\n\n    // Draw the image centered and scaled to fit the wheel's container:\n    // For convenience, scale the 'normal' image to the size of the wheel radius\n    // (so a change in the wheel radius won't require the image to also be updated).\n    const size = isOverlay ? this._size : this._size * this.radius;\n    const sizeHalf = -(size / 2);\n\n    ctx.drawImage(\n      image,\n      sizeHalf,\n      sizeHalf,\n      size,\n      size\n    );\n\n    ctx.resetTransform();\n\n  }\n\n  drawPointerLine(ctx) {\n\n    if (!this.debug) return;\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    ctx.rotate(util.degRad(this._pointerAngle + Constants.arcAdjust));\n\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(this._actualRadius * 2, 0);\n\n    ctx.strokeStyle = Constants.Debugging.pointerLineColor;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n\n    ctx.resetTransform();\n\n  }\n\n  drawBorder(ctx) {\n\n    if (this._borderWidth <= 0) return;\n\n    const actualBorderWidth = this.getActualBorderWidth();\n    const actualBorderColor = this._borderColor || 'transparent';\n\n    ctx.beginPath();\n    ctx.strokeStyle = actualBorderColor;\n    ctx.lineWidth = actualBorderWidth;\n    ctx.arc(this._center.x, this._center.y, this._actualRadius - (actualBorderWidth / 2), 0, 2 * Math.PI);\n    ctx.stroke();\n\n    if (this.debug) {\n      ctx.beginPath();\n      ctx.strokeStyle = ctx.strokeStyle = Constants.Debugging.labelRadiusColor;\n      ctx.lineWidth = 1;\n      ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadius, 0, 2 * Math.PI);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = ctx.strokeStyle = Constants.Debugging.labelRadiusColor;\n      ctx.lineWidth = 1;\n      ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadiusMax, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n  }\n\n  drawItemLines(ctx, angles = []) {\n\n    if (this._lineWidth <= 0) return;\n\n    const actualLineWidth = (this._lineWidth / Constants.baseCanvasSize) * this._size;\n    const actualBorderWidth = this.getActualBorderWidth();\n\n    ctx.translate(\n      this._center.x,\n      this._center.y\n    );\n\n    for (const angle of angles) {\n      ctx.rotate(util.degRad(angle.start + Constants.arcAdjust));\n\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(this._actualRadius - actualBorderWidth, 0);\n\n      ctx.strokeStyle = this.lineColor;\n      ctx.lineWidth = actualLineWidth;\n      ctx.stroke();\n\n      ctx.rotate(-util.degRad(angle.start + Constants.arcAdjust));\n    }\n\n    ctx.resetTransform();\n\n  }\n\n  drawItemLabels(ctx, angles = []) {\n\n    const actualItemLabelBaselineOffset = this.itemLabelFontSize * -this.itemLabelBaselineOffset;\n\n    for (const [i, a] of angles.entries()) {\n\n      const item = this._items[i];\n\n      const actualLabelColor = item.labelColor\n        || (this._itemLabelColors[i % this._itemLabelColors.length] // Fall back to a value from the repeating set.\n        || 'transparent'); // Handle empty string/undefined.\n\n      if (item.label.trim() === '' || actualLabelColor === 'transparent') continue;\n\n      ctx.save();\n\n      ctx.clip(item.path);\n\n      const angle = a.start + ((a.end - a.start) / 2);\n\n      ctx.translate(\n        this._center.x + Math.cos(util.degRad(angle + Constants.arcAdjust)) * (this._actualRadius * this.itemLabelRadius),\n        this._center.y + Math.sin(util.degRad(angle + Constants.arcAdjust)) * (this._actualRadius * this.itemLabelRadius)\n      );\n\n      ctx.rotate(util.degRad(angle + Constants.arcAdjust));\n\n      ctx.rotate(util.degRad(this.itemLabelRotation));\n\n      if (this.debug) {\n        // Draw the outline of the label:\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-this.labelMaxWidth, 0);\n\n        ctx.strokeStyle = Constants.Debugging.labelOutlineColor;\n        ctx.lineWidth = 1;\n        ctx.stroke();\n\n        ctx.strokeRect(0, -this.itemLabelFontSize / 2, -this.labelMaxWidth, this.itemLabelFontSize);\n      }\n\n      ctx.fillStyle = actualLabelColor;\n      ctx.fillText(item.label, 0, actualItemLabelBaselineOffset);\n\n      ctx.restore();\n\n    }\n\n  }\n\n  drawDragEvents(ctx) {\n\n    if (!this.debug || !this.dragEvents?.length) return;\n\n    const dragEventsReversed = [...this.dragEvents].reverse();\n\n    for (const [i, event] of dragEventsReversed.entries()) {\n      const percent = (i / this.dragEvents.length) * 100;\n      ctx.beginPath();\n      ctx.arc(event.x, event.y, 5, 0, 2 * Math.PI);\n      ctx.fillStyle = `hsl(${Constants.Debugging.dragEventHue},100%,${percent}%)`;\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 0.5;\n      ctx.fill();\n      ctx.stroke();\n    }\n\n  }\n\n  animateRotation(now = 0) {\n\n    // For spinTo()\n    if (this._spinToTimeEnd !== undefined) {\n\n      // Check if we should end the animation:\n      if (now >= this._spinToTimeEnd) {\n        this.rotation = this._spinToEndRotation;\n        this._spinToTimeEnd = undefined;\n\n        util.dispatchEvent(this, Constants.EventName.rest, {\n          currentIndex: this._currentIndex,\n          rotation: this._rotation,\n        });\n\n        return;\n      }\n\n      const duration = this._spinToTimeEnd - this._spinToTimeStart;\n      let delta = (now - this._spinToTimeStart) / duration;\n      delta = (delta < 0)? 0 : delta; // Frame time may be before the start time.\n      const distance = this._spinToEndRotation - this._spinToStartRotation;\n\n      this.rotation = this._spinToStartRotation + distance * this._spinToEasingFunction(delta);\n\n      this.refresh();\n\n      return;\n\n    }\n\n    // For spin()\n    if (this._lastSpinFrameTime !== undefined) {\n\n      const delta = now - this._lastSpinFrameTime;\n\n      if (delta > 0) {\n\n        this.rotation += ((delta / 1000) * this._rotationSpeed) % 360; // TODO: very small rounding errors can accumulative here.\n        this._rotationSpeed = this.getRotationSpeedPlusDrag(delta);\n\n        // Check if we should end the animation:\n        if (this._rotationSpeed === 0) {\n\n          util.dispatchEvent(this, Constants.EventName.rest, {\n            currentIndex: this._currentIndex,\n            rotation: this._rotation,\n          });\n\n          this._lastSpinFrameTime = undefined;\n        } else {\n          this._lastSpinFrameTime = now;\n        }\n\n      }\n\n      this.refresh();\n\n      return;\n\n    }\n\n  }\n\n  getRotationSpeedPlusDrag(delta = 0) {\n\n    // Simulate drag:\n    const newRotationSpeed = this._rotationSpeed + ((this.rotationResistance * (delta / 1000)) * this._rotationDirection);\n\n    // Stop rotation once speed reaches 0.\n    // Otherwise the wheel could rotate in the opposite direction next frame.\n    if ((this._rotationDirection === 1 && newRotationSpeed < 0) || (this._rotationDirection === -1 && newRotationSpeed >= 0)) {\n      return 0;\n    }\n\n    return newRotationSpeed;\n\n  }\n\n  /**\n   * Spin the wheel by setting `rotationSpeed`.\n   * The wheel will immediately start spinning, and slow down over time depending on the value of `rotationResistance`.\n   * A positive number will spin clockwise, a negative number will spin anticlockwise.\n   */\n  spin(rotationSpeed = 0) {\n    if (!util.isNumber(rotationSpeed)) throw new Error('rotationSpeed must be a number');\n    this.beginSpin(rotationSpeed, 'spin');\n  }\n\n  /**\n   * Spin the wheel to a particular rotation.\n   * The animation will occur over the provided `duration` (milliseconds).\n   * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n   * If no easing function is provided, the default easeSinOut will be used.\n   * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n   */\n  spinTo(rotation = 0, duration = 0, easingFunction = null) {\n\n    if (!util.isNumber(rotation)) throw new Error('Error: rotation must be a number');\n    if (!util.isNumber(duration)) throw new Error('Error: duration must be a number');\n\n    this.stop();\n\n    this.animate(rotation, duration, easingFunction);\n\n    util.dispatchEvent(this, Constants.EventName.spin, {\n      duration,\n      method: 'spinto',\n      targetRotation: rotation,\n    });\n\n  }\n\n  /**\n   * Spin the wheel to a particular item.\n   * The animation will occur over the provided `duration` (milliseconds).\n   * If `spinToCenter` is true, the wheel will spin to the center of the item, otherwise the wheel will spin to a random angle inside the item.\n   * `numberOfRevolutions` controls how many times the wheel will rotate a full 360 degrees before resting on the item.\n   * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n   * If no easing function is provided, the default easeSinOut will be used.\n   * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n   */\n  spinToItem(itemIndex = 0, duration = 0, spinToCenter = true, numberOfRevolutions = 1, direction = 1, easingFunction = null) {\n\n    this.stop();\n\n    const itemAngle = spinToCenter ? this.items[itemIndex].getCenterAngle() : this.items[itemIndex].getRandomAngle();\n\n    let newRotation = util.calcWheelRotationForTargetAngle(this.rotation, itemAngle - this._pointerAngle, direction);\n    newRotation += ((numberOfRevolutions * 360) * direction);\n\n    this.animate(newRotation, duration, easingFunction);\n\n    util.dispatchEvent(this, Constants.EventName.spin, {\n      duration,\n      method: 'spintoitem',\n      targetItemIndex: itemIndex,\n      targetRotation: newRotation,\n    });\n\n  }\n\n  animate(newRotation, duration, easingFunction) {\n    this._spinToStartRotation = this.rotation;\n    this._spinToEndRotation = newRotation;\n    this._spinToTimeStart = performance.now();\n    this._spinToTimeEnd = this._spinToTimeStart + duration;\n    this._spinToEasingFunction = easingFunction || util.easeSinOut;\n    this.refresh();\n  }\n\n  /**\n   * Immediately stop the wheel from spinning, regardless of which method was used to spin it.\n   */\n  stop() {\n\n    // Stop the wheel if it was spun via `spin()`.\n    this._rotationSpeed = 0;\n\n    // Stop the wheel if it was spun via `spinTo()`.\n    this._spinToTimeEnd = undefined;\n\n  }\n\n  /**\n   * Return the scaled border size.\n   */\n  getActualBorderWidth() {\n     return (this._borderWidth / Constants.baseCanvasSize) * this._size;\n  }\n\n  getActualPixelRatio() {\n    return (this._pixelRatio !== 0) ? this._pixelRatio : window.devicePixelRatio;\n  }\n\n  /**\n   * Return true if the given point is inside the wheel.\n   */\n  wheelHitTest(point = {x:0, y:0}) {\n    const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n    return util.isPointInCircle(p, this._center.x, this._center.y, this._actualRadius);\n  }\n\n  /**\n   * Refresh the cursor state.\n   * Call this after the pointer moves.\n   */\n  refreshCursor() {\n\n    if (this.isInteractive) {\n\n      if (this.isDragging) {\n        this.canvas.style.cursor = 'grabbing';\n        return;\n      }\n\n      if (this.isCursorOverWheel) {\n        this.canvas.style.cursor = 'grab';\n        return;\n      }\n\n    }\n\n    this.canvas.style.cursor = '';\n\n  }\n\n  /**\n   * Get the angle (in degrees) of the given point from the center of the wheel.\n   * 0 is north.\n   */\n  getAngleFromCenter(point = {x:0, y:0}) {\n    return (util.getAngle(this._center.x, this._center.y, point.x, point.y) + 90) % 360;\n  }\n\n  /**\n   * Get the index of the item that the Pointer is pointing at.\n   * An item is considered \"current\" if `pointerAngle` is between it's start angle (inclusive)\n   * and it's end angle (exclusive).\n   */\n  getCurrentIndex() {\n    return this._currentIndex;\n  }\n\n  /**\n   * Calculate and set `currentIndex`\n   */\n  refreshCurrentIndex(angles = []) {\n    if (this._items.length === 0) this._currentIndex = -1;\n\n    for (const [i, a] of angles.entries()) {\n\n      if (!util.isAngleBetween(this._pointerAngle, a.start % 360, a.end % 360)) continue;\n\n      if (this._currentIndex === i) break;\n\n      this._currentIndex = i;\n\n      if (!this._isInitialising) {\n        util.dispatchEvent(this, Constants.EventName.currentIndexChange, {\n          currentIndex: this._currentIndex,\n        });\n      }\n\n      break;\n\n    }\n  }\n\n  /**\n   * Return an array of objects containing the start angle (inclusive) and end angle (inclusive) of each item.\n   */\n  getItemAngles(initialRotation = 0) {\n\n    let weightSum = 0;\n    for (const i of this.items) {\n      weightSum += i.weight;\n    }\n    const weightedItemAngle = 360 / weightSum;\n\n    let itemAngle;\n    let lastItemAngle = initialRotation;\n    const angles = [];\n\n    for (const item of this._items) {\n      itemAngle = item.weight * weightedItemAngle;\n      angles.push({\n        start: lastItemAngle,\n        end: lastItemAngle + itemAngle,\n      });\n      lastItemAngle += itemAngle;\n    }\n\n    // Ensure the difference between last angle.end and first angle.start is exactly 360 degrees.\n    // Sometimes floating point arithmetic pushes the end value past 360 degrees by\n    // a very small amount, which causes issues when calculating `currentIndex`.\n    if (this._items.length > 1) {\n      angles[angles.length - 1].end = angles[0].start + 360;\n    }\n\n    return angles;\n\n  }\n\n  /**\n   * Schedule a redraw of the wheel on the canvas.\n   * Call this after changing any property of the wheel that relates to it's appearance.\n   */\n  refresh() {\n    if (this._frameRequestId === null) {\n      this._frameRequestId = window.requestAnimationFrame(t => this.draw(t));\n    }\n  }\n\n  limitSpeed(speed = 0, max = 0) {\n    // Max is always a positive number, but speed may be positive or negative.\n    const newSpeed = Math.min(speed, max);\n    return Math.max(newSpeed, -max);\n  }\n\n  beginSpin(speed = 0, spinMethod = '') {\n    this.stop();\n\n    this._rotationSpeed = this.limitSpeed(speed, this._rotationSpeedMax);\n    this._lastSpinFrameTime = performance.now();\n\n    this._rotationDirection = (this._rotationSpeed >= 0) ? 1 : -1; // 1 for clockwise or stationary, -1 for anticlockwise.\n\n    if (this._rotationSpeed !== 0) {\n      util.dispatchEvent(this, Constants.EventName.spin, {\n        method: spinMethod,\n        rotationResistance: this._rotationResistance,\n        rotationSpeed: this._rotationSpeed,\n      });\n    }\n\n    this.refresh();\n  }\n\n  /**\n   * The color of the line around the circumference of the wheel.\n   */\n  get borderColor() {\n    return this._borderColor;\n  }\n  set borderColor(val) {\n    this._borderColor = util.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.borderColor must be a string',\n      defaultValue: Defaults.wheel.borderColor,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The width (in pixels) of the line around the circumference of the wheel.\n   */\n  get borderWidth() {\n    return this._borderWidth;\n  }\n  set borderWidth(val) {\n    this._borderWidth = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.borderWidth must be a number',\n      defaultValue: Defaults.wheel.borderWidth,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * Show debugging info.\n   * This is particularly helpful when fine-tuning labels.\n   */\n  get debug() {\n    return this._debug;\n  }\n  set debug(val) {\n    this._debug = util.setProp({\n      val,\n      isValid: typeof val === 'boolean',\n      errorMessage: 'Wheel.debug must be a boolean',\n      defaultValue: Defaults.wheel.debug,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The url of an image that will be drawn over the center of the wheel which will rotate with the wheel.\n   * It will be automatically scaled to fit `radius`.\n   */\n  get image() {\n    return this._image?.src ?? null;\n  }\n  set image(val) {\n    this._image = util.setProp({\n      val,\n      isValid: typeof val === 'string' || val === null,\n      errorMessage: 'Wheel.image must be a url (string) or null',\n      defaultValue: Defaults.wheel.image,\n      action: () => {\n        if (val === null) return null;\n        const v = new Image();\n        v.src = val;\n        v.onload = e => this.refresh();\n        return v;\n      },\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * Allow the user to spin the wheel using click-drag/touch-flick.\n   * User interaction will only be detected within the bounds of `Wheel.radius`.\n   */\n  get isInteractive() {\n    return this._isInteractive;\n  }\n  set isInteractive(val) {\n    this._isInteractive = util.setProp({\n      val,\n      isValid: typeof val === 'boolean',\n      errorMessage: 'Wheel.isInteractive must be a boolean',\n      defaultValue: Defaults.wheel.isInteractive,\n    });\n\n    this.refreshCursor(); // Reset the cursor in case the wheel is currently being dragged.\n  }\n\n  /**\n   * The repeating pattern of background colors for all items.\n   * Overridden by `Item.backgroundColor`.\n   * Example: `['#fff','#000']`.\n   */\n  get itemBackgroundColors() {\n    return this._itemBackgroundColors;\n  }\n  set itemBackgroundColors(val) {\n    this._itemBackgroundColors = util.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.itemBackgroundColors must be an array',\n      defaultValue: Defaults.wheel.itemBackgroundColors,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The alignment of all item labels.\n   * Accepted values: `'left'`|`'center'`|`'right'`.\n   * You may need to set `itemLabelRotation` in combination with this.\n   */\n  get itemLabelAlign() {\n    return this._itemLabelAlign;\n  }\n  set itemLabelAlign(val) {\n    this._itemLabelAlign = util.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.itemLabelAlign must be a string',\n      defaultValue: Defaults.wheel.itemLabelAlign,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The offset of the baseline (or line height) of all item labels (as a percent of the label's height).\n   */\n  get itemLabelBaselineOffset() {\n    return this._itemLabelBaselineOffset;\n  }\n  set itemLabelBaselineOffset(val) {\n    this._itemLabelBaselineOffset = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.itemLabelBaselineOffset must be a number',\n      defaultValue: Defaults.wheel.itemLabelBaselineOffset,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The repeating pattern of colors for all item labels.\n   * Overridden by `Item.labelColor`.\n   * Example: `['#fff','#000']`.\n   */\n  get itemLabelColors() {\n    return this._itemLabelColors;\n  }\n  set itemLabelColors(val) {\n    this._itemLabelColors = util.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.itemLabelColors must be an array',\n      defaultValue: Defaults.wheel.itemLabelColors,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The font family for all item labels.\n   * Overridden by `Item.labelFont`.\n   * Example: `'sans-serif'`.\n   */\n  get itemLabelFont() {\n    return this._itemLabelFont;\n  }\n  set itemLabelFont(val) {\n    this._itemLabelFont = util.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.itemLabelFont must be a string',\n      defaultValue: Defaults.wheel.itemLabelFont,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The maximum font size (in pixels) for all item labels.\n   */\n  get itemLabelFontSizeMax() {\n    return this._itemLabelFontSizeMax;\n  }\n  set itemLabelFontSizeMax(val) {\n    this._itemLabelFontSizeMax = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.itemLabelFontSizeMax must be a number',\n      defaultValue: Defaults.wheel.itemLabelFontSizeMax,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel)\n   * to start drawing all item labels.\n   */\n  get itemLabelRadius() {\n    return this._itemLabelRadius;\n  }\n  set itemLabelRadius(val) {\n    this._itemLabelRadius = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRadius must be a number',\n      defaultValue: Defaults.wheel.itemLabelRadius,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The point along the radius (as a percent, starting from the center of the wheel)\n   * to calculate the maximum font size for all item labels.\n   */\n  get itemLabelRadiusMax() {\n    return this._itemLabelRadiusMax;\n  }\n  set itemLabelRadiusMax(val) {\n    this._itemLabelRadiusMax = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRadiusMax must be a number',\n      defaultValue: Defaults.wheel.itemLabelRadiusMax,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The rotation of all item labels.\n   * Use this to flip the labels `180\u00B0` in combination with `itemLabelAlign`.\n   */\n  get itemLabelRotation() {\n    return this._itemLabelRotation;\n  }\n  set itemLabelRotation(val) {\n    this._itemLabelRotation = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.itemLabelRotation must be a number',\n      defaultValue: Defaults.wheel.itemLabelRotation,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The items to show on the wheel.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(val) {\n    this._items = util.setProp({\n      val,\n      isValid: Array.isArray(val),\n      errorMessage: 'Wheel.items must be an array of Items',\n      defaultValue: Defaults.wheel.items,\n      action: () => {\n        const v = [];\n        for (const item of val) {\n          v.push(new Item(this, {\n            backgroundColor: item.backgroundColor,\n            image: item.image,\n            imageRadius: item.imageRadius,\n            imageRotation: item.imageRotation,\n            imageScale: item.imageScale,\n            label: item.label,\n            labelColor: item.labelColor,\n            value: item.value,\n            weight: item.weight,\n          }));\n        }\n        return v;\n      },\n    });\n\n    this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n    this.resize(); // Refresh item label font size.\n  }\n\n  /**\n   * The color of the lines between the items.\n   */\n  get lineColor() {\n    return this._lineColor;\n  }\n  set lineColor(val) {\n    this._lineColor = util.setProp({\n      val,\n      isValid: typeof val === 'string',\n      errorMessage: 'Wheel.lineColor must be a string',\n      defaultValue: Defaults.wheel.lineColor,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The width (in pixels) of the lines between the items.\n   */\n  get lineWidth() {\n    return this._lineWidth;\n  }\n  set lineWidth(val) {\n    this._lineWidth = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.lineWidth must be a number',\n      defaultValue: Defaults.wheel.lineWidth,\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The offset of the wheel relative to it's center (as a percent of the wheel's diameter).\n   */\n  get offset() {\n    return this._offset;\n  }\n  set offset(val) {\n    this._offset = util.setProp({\n      val,\n      isValid: util.isObject(val),\n      errorMessage: 'Wheel.offset must be an object',\n      defaultValue: Defaults.wheel.offset,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The url of an image that will be drawn over the center of the wheel which will not rotate with the wheel.\n   * It will be automatically scaled to fit the container's smallest dimension.\n   * Use this to draw decorations around the wheel, such as a stand or pointer.\n   */\n  get overlayImage() {\n    return this._overlayImage?.src ?? null;\n  }\n  set overlayImage(val) {\n    this._overlayImage = util.setProp({\n      val,\n      isValid: typeof val === 'string' || val === null,\n      errorMessage: 'Wheel.overlayImage must be a url (string) or null',\n      defaultValue: Defaults.wheel.overlayImage,\n      action: () => {\n        if (val === null) return null;\n        const v = new Image();\n        v.src = val;\n        v.onload = e => this.refresh();\n        return v;\n      },\n    });\n\n    this.refresh();\n  }\n\n  /**\n   * The pixel ratio used to render the wheel.\n   * Values above 0 will produce a sharper image at the cost of performance.\n   * A value of `0` will cause the pixel ratio to be automatically determined using `window.devicePixelRatio`.\n   */\n  get pixelRatio() {\n    return this._pixelRatio;\n  }\n  set pixelRatio(val) {\n    this._pixelRatio = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.pixelRatio must be a number',\n      defaultValue: Defaults.wheel.pixelRatio,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The angle of the Pointer which is used to determine the `currentIndex` (or the \"winning\" item).\n   */\n  get pointerAngle() {\n    return this._pointerAngle;\n  }\n  set pointerAngle(val) {\n    this._pointerAngle = util.setProp({\n      val,\n      isValid: util.isNumber(val) && val >= 0,\n      errorMessage: 'Wheel.pointerAngle must be a number between 0 and 360',\n      defaultValue: Defaults.wheel.pointerAngle,\n      action: () => val % 360,\n    });\n\n    if (this.debug) this.refresh();\n  }\n\n  /**\n   * The radius of the wheel (as a percent of the container's smallest dimension).\n   */\n  get radius() {\n    return this._radius;\n  }\n  set radius(val) {\n    this._radius = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.radius must be a number',\n      defaultValue: Defaults.wheel.radius,\n    });\n\n    this.resize();\n  }\n\n  /**\n   * The rotation (angle in degrees) of the wheel.\n   * `0` is north.\n   * The first item will be drawn clockwise from this point.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(val) {\n    this._rotation = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.rotation must be a number',\n      defaultValue: Defaults.wheel.rotation,\n    });\n\n    this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n    this.refresh();\n  }\n\n  /**\n   * The amount that `rotationSpeed` will be reduced by every second.\n   * Only in effect when `rotationSpeed !== 0`.\n   * Set to `0` to spin the wheel infinitely.\n   */\n  get rotationResistance() {\n    return this._rotationResistance;\n  }\n  set rotationResistance(val) {\n    this._rotationResistance = util.setProp({\n      val,\n      isValid: util.isNumber(val),\n      errorMessage: 'Wheel.rotationResistance must be a number',\n      defaultValue: Defaults.wheel.rotationResistance,\n    });\n  }\n\n  /**\n   * (Readonly) How far (angle in degrees) the wheel will spin every 1 second.\n   * A positive number means the wheel is spinning clockwise, a negative number means anticlockwise, and `0` means the wheel is not spinning.\n   */\n  get rotationSpeed() {\n    return this._rotationSpeed;\n  }\n\n  /**\n   * The maximum value for `rotationSpeed` (ignoring the wheel's spin direction).\n   * The wheel will not spin faster than this value in any direction.\n   */\n  get rotationSpeedMax() {\n    return this._rotationSpeedMax;\n  }\n  set rotationSpeedMax(val) {\n    this._rotationSpeedMax = util.setProp({\n      val,\n      isValid: util.isNumber(val) && val >= 0,\n      errorMessage: 'Wheel.rotationSpeedMax must be a number >= 0',\n      defaultValue: Defaults.wheel.rotationSpeedMax,\n    });\n  }\n\n  /**\n   * Enter the drag state.\n   */\n  dragStart(point = {x:0, y:0}) {\n\n    const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n\n    this.isDragging = true;\n\n    this.stop(); // Interrupt `spinTo()`\n\n    this.dragEvents = [{\n      distance: 0,\n      x: p.x,\n      y: p.y,\n      now:performance.now(),\n    }];\n\n    this.refreshCursor();\n\n  }\n\n  dragMove(point = {x:0, y:0}) {\n\n    const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n    const a = this.getAngleFromCenter(p);\n\n    const lastDragPoint = this.dragEvents[0];\n    const lastAngle = this.getAngleFromCenter(lastDragPoint);\n    const angleSinceLastMove = util.diffAngle(lastAngle, a);\n\n    this.dragEvents.unshift({\n      distance: angleSinceLastMove,\n      x: p.x,\n      y: p.y,\n      now:performance.now(),\n    });\n\n    // Retain max 40 events when debugging.\n    if (this.debug && this.dragEvents.length >= 40) this.dragEvents.pop();\n\n    // Snap the wheel to the new rotation.\n    this.rotation += angleSinceLastMove; // TODO: can we apply easing here so it looks nicer?\n\n  }\n\n  /**\n   * Exit the drag state.\n   * Set the rotation speed so the wheel continues to spin in the same direction.\n   */\n  dragEnd() {\n\n    this.isDragging = false;\n\n    // Calc the drag distance:\n    let dragDistance = 0;\n    const now = performance.now();\n\n    for (const [i, event] of this.dragEvents.entries()) {\n\n      if (!this.isDragEventTooOld(now, event)) {\n        dragDistance += event.distance;\n        continue;\n      }\n\n      // Exclude old events:\n      this.dragEvents.length = i;\n      break;\n\n    }\n\n    this.refreshCursor();\n\n    if (dragDistance === 0) return;\n\n    this.beginSpin(dragDistance * (1000 / Constants.dragCapturePeriod), 'interact');\n\n  }\n\n  isDragEventTooOld(now = 0, event = {}) {\n    return (now - event.now) > Constants.dragCapturePeriod;\n  }\n\n});\n"],
  "mappings": "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",
  "names": ["getRandomFloat", "min", "max", "round", "degRad", "degrees", "isAngleBetween", "angle", "arcStart", "arcEnd", "getFontSizeToFit", "text", "fontFamily", "maxWidth", "canvasContext", "w", "isPointInCircle", "point", "cx", "cy", "radius", "__pow", "translateXYToElement", "element", "devicePixelRatio", "rect", "getAngle", "originX", "originY", "targetX", "targetY", "dx", "dy", "theta", "addAngle", "a", "b", "sum", "result", "diffAngle", "offsetFrom180", "calcWheelRotationForTargetAngle", "currentRotation", "targetAngle", "direction", "angle", "fixFloat", "isObject", "v", "isNumber", "n", "setProp", "val", "isValid", "errorMessage", "defaultValue", "action", "isImageLoaded", "image", "f", "easeSinOut", "dispatchEvent", "el", "eventName", "detail", "event", "AlignText", "Defaults", "Debugging", "EventName", "register", "wheel", "registerPointerEvents", "e", "updatePixelRatio", "unregister", "canvas", "point", "onPointerMove", "onPointerUp", "onMouseMove", "onMouseUp", "onTouchMove", "onTouchEnd", "Item", "wheel", "props", "isObject", "Defaults", "val", "_a", "_b", "img", "e", "index", "i", "angle", "getRandomFloat", "shadow", "i", "Defaults", "register", "unregister", "props", "isObject", "w", "h", "minSize", "wheelSize", "scale", "item", "getFontSizeToFit", "now", "ctx", "angles", "actualBorderWidth", "path", "degRad", "_a", "a", "isImageLoaded", "angle", "width", "height", "widthHalf", "heightHalf", "image", "isOverlay", "size", "sizeHalf", "Debugging", "actualBorderColor", "actualLineWidth", "actualItemLabelBaselineOffset", "actualLabelColor", "dragEventsReversed", "event", "percent", "dispatchEvent", "EventName", "duration", "delta", "distance", "newRotationSpeed", "rotationSpeed", "isNumber", "rotation", "easingFunction", "itemIndex", "spinToCenter", "numberOfRevolutions", "direction", "itemAngle", "newRotation", "calcWheelRotationForTargetAngle", "easeSinOut", "point", "p", "translateXYToElement", "isPointInCircle", "getAngle", "isAngleBetween", "initialRotation", "weightSum", "weightedItemAngle", "lastItemAngle", "t", "speed", "max", "newSpeed", "spinMethod", "val", "setProp", "_b", "v", "e", "Item", "lastDragPoint", "lastAngle", "angleSinceLastMove", "diffAngle", "dragDistance"]
}
